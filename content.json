{"meta":{"title":"強い","subtitle":"学习，是为了变成更好的自己， 将来的你，一定会感谢现在努力的自己！","description":"付大强,付大強,baidu付大强,百度付大强,大強,大强,小強,小强,強,强,小强强,强强,小強強,強強,付大強い,我不是苏大强,苏大强不是我,我是付大强，不是苏大强,关于付大强,付大强个人简历,web付大强,前端付大强,小强精神,付大强的个人博客,前端小强,付大强的个人首页,付大强的个人中心,付大强的个人主页,打不死的小强,关于付大強,付大強个人简历,web付大強,前端付大強,小強精神,付大強的个人博客,前端小強,付大強的个人首页,付大強的个人中心,付大強的个人主页,打不死的小強,fudaqiang,FUDAQIANG,FDQ,小鬼,","author":"付大强","url":"https://www.fudaqiang.com"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-04-08T07:10:27.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://www.fudaqiang.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-04-08T07:10:27.000Z","comments":false,"path":"about/index.html","permalink":"https://www.fudaqiang.com/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-04-08T07:10:27.000Z","comments":true,"path":"comment/index.html","permalink":"https://www.fudaqiang.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-04-08T07:10:27.000Z","comments":false,"path":"donate/index.html","permalink":"https://www.fudaqiang.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-04-08T07:10:27.000Z","comments":false,"path":"client/index.html","permalink":"https://www.fudaqiang.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-04-08T11:35:47.000Z","comments":false,"path":"music/index.html","permalink":"https://www.fudaqiang.com/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-04-08T11:09:45.000Z","comments":true,"path":"links/index.html","permalink":"https://www.fudaqiang.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-04-08T07:10:27.000Z","comments":true,"path":"rss/index.html","permalink":"https://www.fudaqiang.com/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-04-08T07:10:27.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.fudaqiang.com/tags/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-04-08T07:10:27.000Z","comments":false,"path":"lab/index.html","permalink":"https://www.fudaqiang.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-04-08T07:10:27.000Z","comments":false,"path":"video/index.html","permalink":"https://www.fudaqiang.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-04-08T07:10:27.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://www.fudaqiang.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"Vue组件开发props验证","slug":"Vue组件开发props验证","date":"2019-05-08T06:51:53.000Z","updated":"2019-05-09T06:11:47.683Z","comments":true,"path":"2019/05/08/Vue组件开发props验证/","link":"","permalink":"https://www.fudaqiang.com/2019/05/08/Vue组件开发props验证/","excerpt":"","text":"props为啥要验证一下 它们写明了组件的API,所以很容易看懂组件的用法 在开发环境中，如果向一个组件提供格式不正确的prop，Vue将会警告，可以帮助我们捕获潜在的错误来源。 type可以使用type来声明这个参数可以接受的数据的类型，当检查规则只有一个的时候type可以略写type能够指定的类型String、Number、Boolean、Functio、Object、Array、Symbol props: { fooMessage: { type: Number, } } required可以使用required选项来声明这个参数是否必须传入 props: { fooMessage: { type: Number, required: true } } default使用default选项来指定当前父组件未传入参数时props变量的默认值 props: { fooMessage: { type: String, default: &quot;我是默认信息&quot; } } 当type的类型为Array或者Object的时候default必须是一个函数： props: { fooMessage: { type: Array, default: function(){ return [&quot;yes&quot;, &quot;no&quot;]; } } } JS中对象和数组是引用类型，指向同一个内存空间，如果 props 是一个对象或数组，在子组件内部改变它会影响父组件的状态 不懂就点我吧validator当效验规则很复杂，默认提供的效验规则无法满足的时候可以使用自定义函数来效验。 props: { fooMessage: { validator: function(value){ return value&gt;=0 &amp;&amp; value&lt;=128; } } } 一个综合的例子props: { // fooA只接受数值类型的参数 fooA: Number, // fooB可以接受字符串和数值类型的参数 fooB: [String, Number], // fooC可以接受字符串类型的参数，并且这个参数必须传入 fooC: { type: String, required: true }, // fooD接受数值类型的参数，如果不传入的话默认就是100 fooD: { type: Number, default: 100 }, // fooE接受对象类型的参数 fooE: { type: Object, // 当为对象类型设置默认值时必须使用函数返回 default: function(){ return { message: &#39;Hello, world&#39; } } }, // fooF使用一个自定义的验证器 fooF: { validator: function(value){ return value&gt;=0 &amp;&amp; value&lt;=100; } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"Hexo-修改文章链接的默认格式","slug":"Hexo-修改文章链接的默认格式","date":"2019-05-08T06:40:19.000Z","updated":"2019-05-08T06:45:31.453Z","comments":true,"path":"2019/05/08/Hexo-修改文章链接的默认格式/","link":"","permalink":"https://www.fudaqiang.com/2019/05/08/Hexo-修改文章链接的默认格式/","excerpt":"","text":"Hexo的永久链接的默认格式是 :year/:month/:day/:title/，比如访问站点下某一篇文章时，其路径是 2018/04/12/xxxx/，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。 解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。 安装插件在站点根目录使用 git bash 执行命令： npm install hexo-abbrlink –save 修改站点配置文件打开根目录下的 _config.yml 文件，修改如下配置： # permalink: :year/:month/:day/:title/ # permalink_defaults: permalink: :year/:abbrlink.html abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex123456 这里将页面都添加了 .html 的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。 接下来重新部署三连，可以看到我们的文章路径变成了 /2018/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"程序员语录","slug":"程序员语录","date":"2019-05-08T06:35:09.000Z","updated":"2019-05-09T02:34:37.535Z","comments":true,"path":"2019/05/08/程序员语录/","link":"","permalink":"https://www.fudaqiang.com/2019/05/08/程序员语录/","excerpt":"","text":"学习，是为了变成更好的自己， 将来的你，一定会感谢现在努力的自己！ 好的代码像粥一样，都是用时间熬出来的 有志者自有千计万计，无志者只感千难万难。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"Vue组件的data为什么是函数而不是对象","slug":"Vue组件的data为什么是函数而不是对象","date":"2019-05-08T03:08:53.000Z","updated":"2019-05-08T07:26:17.697Z","comments":true,"path":"2019/05/08/Vue组件的data为什么是函数而不是对象/","link":"","permalink":"https://www.fudaqiang.com/2019/05/08/Vue组件的data为什么是函数而不是对象/","excerpt":"","text":"Vue组件中为什么data是一个函数当在组件中使用data属性的时候（除了new Vue 外的任何地方），它的值必须是返回一个对象的函数。既然必须返回一个对象，为什么data不直接使用对象呢 当data的值是一个对象时，它会在这个组件的所有实例之间共享。想象一下，假如一个 TodoList 组件的数据是这样的： Vue.component(&#39;some-comp&#39;, { data: { listTitle: &#39;&#39;, todos: [] } }) 我们可能希望重用这个组件，允许用户维护多个列表（比如购物、收藏、日常事务等）。这时就会产生问题。因为每个组件的实例都引用了相同的数据对象，更改其中一个列表的标题就会改变每一个组件的标题。增删改也是如此。不懂就点我吧 取而代之的是，我们希望每一个组件实例都管理着自己的数据，为了做到这一点，每个实例必须生成一个独立的数据对象。在javascript中，在一个函数中返回这个对象就可以了： Vue.component(&#39;some-comp&#39;, { data: function () { return { foo: &#39;bar&#39; } } }) 为什么根实例的data是一个对象呢new Vue({ data: { foo: &#39;bar&#39; } }) 因为在Vue中只有一个实例，所以在vue的根实例上可以直接使用对象","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"js基本数据类型和引用数据类型的区别","slug":"js基本数据类型和引用数据类型的区别","date":"2019-05-07T02:45:12.000Z","updated":"2019-05-07T11:56:38.851Z","comments":true,"path":"2019/05/07/js基本数据类型和引用数据类型的区别/","link":"","permalink":"https://www.fudaqiang.com/2019/05/07/js基本数据类型和引用数据类型的区别/","excerpt":"","text":"栈（stack）和堆（heap）stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放 js分为基本数据类型和引用数据类型基本数据类型指的是简单的数据段,数据大小确实，内存空间大小可以分配，他们是直接按值存放的，所以可以直接`按值访问` 引用数据类型指的是有多个值构成的对象。 当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型还是引用数据类型。 基本数据类型(放在栈中）Number、 String、Boolean、Null、Undefined、Symbol（ES6） 基本数据类型是按值访问的。因为可以直接操作保存在变量中的实际值。 var a = 10; var b = a; b = 20; console.log(a); //10 console.log(b); //20 基本数据类型是对值的重新赋值，b先被赋值上了a的值10，b又被重新赋值为20。此时b的值为20，a没有被重新赋值，所以a 还是10 引用数据类型(存放在堆内存中的对象，每个空间大小不一样，要根据情况进行特定的配置)Object、Array、Function、Data 等 js的引用数据类型是保存在堆内存的对象 与其他语言的不同是，你不可以直接访问堆内存空间中的位置和堆内存空间。只能操作对象在栈内存中的引用地址。所以，引用数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存在堆内存中的对象。 var obj1 = new Object(); var obj2 = obj1; obj2.name = &quot;haha&quot;; console.log(obj1.name) //haha 这说明两个引用数据类型指向了同一个堆内存对象。obj1赋值给了obj2，实际上这个堆内存对象在栈内存堆引用地址复制了一份给了obj2,实际上他们共同指向了同一个堆内存对象。所以给obj2的某一个属性修改或赋值是obj1的属性也跟着一起改变了 基本类型和引用类型区别 声明变量时内存分配不同 基本类型： 存在栈中，因为占据空间是固定的，可以将他们存在较小的内存中-栈中，这样便于快速查询变量的值 引用类型： 存在堆中，栈中储存的变量，只是用来查找堆中堆引用地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查找速度。相反，放在变量的栈内存中的值是该对象存储在堆内存中堆地址。地址的大小是固定的，所以把它存储在栈内存中的变量性能无任何负面影响 不同的内存分配带来不同的访问机制 在javascript中不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后在按照这个地址去获得这个对象中的值，这就是按引用访问。 而基本类型的值则是可以直接访问到到。 复制变量时的不同 基本类型：在将一个保存着原始值的变量复制给另一个变量时，会将基本类型值赋值给新变量，此后两个变量是完全独立的，他们只是值相同而已 引用类型：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个变量保存在的栈内存地址赋值给新的变量。此时两个变量都指向了在堆内存中的同一个对象，它们中任何一个做出改变都会影响到另一个变量。（复制对象值不过是把栈内存中的指针复制了一个） 参数传递的不同（把实参复制给形参的过程） 基本类型： 只是把变量里的值传递给实参，之后参数和变量互不影响 引用类型： 对象变量它里面的值是这个对象在堆内存中的内存地址，因此它传递的值也就是这个内存地址，这就是为什么函数内部修改了这个参数，函数外部这个对象也修改了，因为它们访问的是 同一个内存地址 看一下代码吧 //基本类型 var a = 12; console.log(a, &quot;a&quot;) //12 function fn(x) { x++; console.log(x, &quot;fn&quot;) //13 } fn(a) console.log(a, &quot;a&quot;) //12 //引用类型 var obj = { a: 12, b: &quot;b&quot; } console.log(obj, &quot;obj&quot;) //{a: 12, b: &quot;b&quot;} function fn2(obj) { obj.a++; console.log(obj, &quot;fn2&quot;) //{a: 13, b: &quot;b&quot;} } fn2(obj) console.log(obj, &quot;obj&quot;) //{a: 13, b: &quot;b&quot;}","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"防抖debounce","slug":"防抖debounce","date":"2019-04-20T10:32:43.000Z","updated":"2019-05-06T03:42:32.707Z","comments":true,"path":"2019/04/20/防抖debounce/","link":"","permalink":"https://www.fudaqiang.com/2019/04/20/防抖debounce/","excerpt":"","text":"function debounce(fn, wait) { var timer = null; return function () { if (timer !== null){ clearTimeout(timer); timer = null; } timer = setTimeout(fn, wait); } }","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"节流throttle","slug":"节流throttle","date":"2019-04-20T10:31:40.000Z","updated":"2019-05-06T03:41:45.390Z","comments":true,"path":"2019/04/20/节流throttle/","link":"","permalink":"https://www.fudaqiang.com/2019/04/20/节流throttle/","excerpt":"","text":"function throttle(fn, wait) { let timer = null; return function () { if (timer) return timer = setTimeout(() =&gt; { fn() timer = null }, wait) }; }; function fn() { console.log(11) } setInterval(throttle(fn, 2000), 100); setInterval(()=&gt;{ console.log(&quot;12&quot;) },1000);","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"前端常问面试题","slug":"前端常问面试题","date":"2019-04-20T10:28:54.000Z","updated":"2019-04-30T03:26:27.000Z","comments":true,"path":"2019/04/20/前端常问面试题/","link":"","permalink":"https://www.fudaqiang.com/2019/04/20/前端常问面试题/","excerpt":"","text":"一、先做个自我介绍吧&emsp;&emsp;吧啦吧啦就说一些… 二、css相关问题1.盒模型&emsp;&emsp;CSS中主要有以下盒模型：inline、inline-block、block、table、position、float。浏览器把每个元素看作一个盒模型，每个盒模型由以下几个属性组合决定的：display、position、float、width、height、margin、padding和border等，不同的盒模型会产生不同的布局 盒模型分为两种：标准盒模型、怪异盒模型 标准盒模型 外盒尺寸计算: Element高度 = 内容高度 + 填充 + 边框 + 外边距 Element宽度 = 内容宽度 + 填充 + 边框 + 外边距 内盒尺寸计算: Element高度 = 内容高度 + 填充 + 边框 Element宽度 = 内容宽度 + 填充 + 边框 怪异盒模型 外盒尺寸计算 Element高度 = 内容高度 + 外距（height包含了元素内容高度、边框、填充） Element宽度 = 内容宽度 + 外距（width包含了元素内容宽度、边框、填充） 内盒尺寸计算 Element高度 = 内容高度（height包含了元素内容高度、边框、填充） Element宽度 = 内容宽度（width包含了元素内容宽度、边框、填充） 无论使用哪种模式完整定义DOCTYPE，都会触发标准模式，而如果DOCTYPE缺失则在ie6，ie7，ie8下将会触发怪异模式（quirks 模式）css3新增盒模型属性box-sizing，能够事先定义盒模型的尺寸解析方式box-sizing:content-box | border-box | inherit 参数说明： &emsp;&emsp;content-box：默认值，让元素维持W3C标准盒模型&emsp;&emsp;border-box：让元素维持IE传统的盒模型（IE6以下版本盒IE6~7怪异模式）&emsp;&emsp;inherit：使元素继承父元素的盒模型模式。老版本浏览器存在兼容问题：1、-moz- firefox浏览器2、-ms- ie浏览器3、-webkit- safari、chrome4、-o- Opera 2.阴影box-shadow box-shadow: x y blur spread color inset;&emsp;&emsp;参数说明: &emsp;&emsp;X 必需。水平阴影的位置。允许负值 &emsp;&emsp;y 必需。垂直阴影的位置。允许负 &emsp;&emsp;blur 可选。模糊距离。 &emsp;&emsp;spread 可选。阴影的尺寸。 &emsp;&emsp;color 可选。阴影的颜色。请参阅 CSS 颜色值。 &emsp;&emsp;inset 可选。将外部阴影 (outset) 改为内部阴影。 box-reflect：倒影 &emsp;&emsp;语法: box-reflect：none | direction offset ? mask-box-image &emsp;&emsp;&emsp;&emsp;direction = above | below | left | right &emsp;&emsp;&emsp;&emsp;offset = length | percentage &emsp;&emsp;&emsp;&emsp;mask-box-image = none | url | linear-gradient | radial-gradient | repeating-linear-gradient | repeating-radial-gradient &emsp;&emsp;参数说明: direction：方向 （必选参数）above | below | left | right&emsp;&emsp;&emsp;&emsp;above：指定倒影在对象的上边&emsp;&emsp;&emsp;&emsp;below：指定倒影在对象的下边&emsp;&emsp;&emsp;&emsp;left：指定倒影在对象的左边&emsp;&emsp;&emsp;&emsp;right：指定倒影在对象的右边offset&emsp;&emsp;&emsp;&emsp;可用长度值来定义倒影与对象之间的间隔。可以为负值&emsp;&emsp;&emsp;&emsp;可用百分比来定义倒影与对象之间的间隔。可以为负值mask-box-image&emsp;&emsp;&emsp;&emsp;url：使用绝对或相对地址指定遮罩图像。&emsp;&emsp;&emsp;&emsp;linear-gradient：使用线性渐变创建遮罩图像。&emsp;&emsp;&emsp;&emsp;radial-gradient：使用径向(放射性)渐变创建遮罩图像。&emsp;&emsp;&emsp;&emsp;repeating-linear-gradient：使用重复的线性渐变创建背遮罩像。&emsp;&emsp;&emsp;&emsp;repeating-radial-gradient：使用重复的径向(放射性)渐变创建遮罩图像。3、弹性盒flex-direction属性 &emsp;&emsp;flex-direction 属性指定了弹性子元素在父容器中的位置。&emsp;&emsp;语法：flex-direction: row | row-reverse | column | column-reverse &emsp;&emsp;参数说明: &emsp;&emsp;&emsp;&emsp;row：横向从左到右排列（左对齐），默认的排列方式 &emsp;&emsp;&emsp;&emsp;row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面） &emsp;&emsp;&emsp;&emsp;column：纵向排列 &emsp;&emsp;&emsp;&emsp;column-reverse：反转纵向排列，从后往前排，最后一项排在最上面 justify-content 属性 &emsp;&emsp;justify-content属性表示内容对齐，应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐 &emsp;&emsp;语法：justify-content: flex-start | flex-end | center | space-between | space-around &emsp;&emsp;参数说明: &emsp;&emsp;&emsp;&emsp;flex-start：项目位于容器的开头，默认值。 &emsp;&emsp;&emsp;&emsp;flex-end：项目位于容器的结尾 &emsp;&emsp;&emsp;&emsp;center：项目位于容器的中心 &emsp;&emsp;&emsp;&emsp;space-between：项目位于各行之间留有空白的容器内 &emsp;&emsp;&emsp;&emsp;space-around：项目位于各行之前、之间、之后都留有空白的容器内 align-items 属性 &emsp;&emsp;align-items 属性设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。 &emsp;&emsp;语法:align-items: flex-start | flex-end | center | baseline | stretch &emsp;&emsp;参数说明: &emsp;&emsp;&emsp;&emsp;flex-start：元素位于容器的开头 &emsp;&emsp;&emsp;&emsp;flex-end：元素位于容器的结尾 &emsp;&emsp;&emsp;&emsp;center：元素位于容器的中心 &emsp;&emsp;&emsp;&emsp;baseline：元素位于容器的基线上 &emsp;&emsp;&emsp;&emsp;stretch：默认值。元素被拉伸以适应容器 flex-wrap 属性 flex-wrap 属性用于指定弹性盒子的子元素换行方式。 &emsp;&emsp;CSS语法 flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;nowrap：默认，弹性容器为单行，该情况下弹性子项可能会溢出容器。 &emsp;&emsp;&emsp;&emsp;wrap ：弹性容器为多行，该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行 &emsp;&emsp;&emsp;&emsp;wrap-reverse ：反转 wrap 排列 align-content 属性 align-content 属性用于修改 flex-wrap 属性的行为。用于设置各个行的对齐 语法: align-content: flex-start | flex-end | center | space-between | space-around | stretch&emsp;&emsp;参数说明: &emsp;&emsp;&emsp;&emsp;stretch ：各行将会伸展以占用剩余的空间，默认值 &emsp;&emsp;&emsp;&emsp;flex-start：各行向弹性盒容器的起始位置堆叠 &emsp;&emsp;&emsp;&emsp;flex-end： 各行向弹性盒容器的结束位置堆叠 &emsp;&emsp;&emsp;&emsp;center ：各行向弹性盒容器的中间位置堆叠 &emsp;&emsp;&emsp;&emsp;space-between：各行在弹性盒容器中平均分布 &emsp;&emsp;&emsp;&emsp;space-around：各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半 4、溢出文本省略号单行文本省略号.text {&emsp;&emsp;overflow: hidden;&emsp;&emsp;text-overflow: ellipsis;&emsp;&emsp;white-space: nowrap }多行文本省略号.test {&emsp;&emsp;overflow: hidden;&emsp;&emsp;text-overflow: ellipsis;&emsp;&emsp;display: -webkit-box;&emsp;&emsp;-webkit-line-clamp: 2; //文本显示多少行&emsp;&emsp;-webkit-box-orient: vertical;} 伪类实现省略号.txt:after {&emsp;&emsp;content: “…”;} 5、css选择器基本选择器&emsp;&emsp; 通配选择器&emsp;&emsp;div 元素选择器&emsp;&emsp;#id ID选择器&emsp;&emsp;.class 类选择器&emsp;&emsp;div,p 群组选择器层次选择器语法 &emsp;&emsp;div p 后代选择器 选择div下所有的元素p &emsp;&emsp;div&gt;p 子选择器 选择div下所有的直属子元素p &emsp;&emsp;div+p 相邻兄弟选择器 选择匹配的p元素，且匹配的p元素紧位于匹配的div元素的后面 &emsp;&emsp;div~p 通用选择器 选择匹配的p元素，且位于匹配的div元素后的所有匹配的p元素结构伪类选择器 &emsp;&emsp;div:fisrt-child 作为父元素的第一个子元素的元素div。与div:nth-child(1)等同 &emsp;&emsp;div:last-child 作为父元素的最后一个子元素的元素E。与div:nth-last-child(1)等同 &emsp;&emsp;ul li:nth-child(n) 选择父元素ul的第n个子元素li。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0 &emsp;&emsp;ul li:nth-last-child(n) 选择父元素ul的倒数第n个子元素li。此选择器与ul:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同 &emsp;&emsp;div:nth-of-type(n) 选择父元素内具有指定类型的第n个div元素 &emsp;&emsp;div:nth-last-of-type(n) 选择父元素内具有指定类型的倒数第n个div元素 &emsp;&emsp;div:first-of-type 选择父元素内具有指定类型的第一个div元素，与div:nth-of-type(1)等同 &emsp;&emsp;div:last-of-tye 选择父元素内具有指定类型的最后一个div元素，与div:nth-last-of-type(1)等同 &emsp;&emsp;div:only-child 选择父元素只包含一个子元素，且该子元素匹配div元素 &emsp;&emsp;div:only-of-type 选择父元素只包含一个同类型子元素，且该子元素匹配div元素 &emsp;&emsp;div:empty 选择没有子元素的元素，而且该元素也不包含任何文本节点否定伪类选择器 &emsp;&emsp;div:not(p) 匹配所有除元素p外的div元素事件伪类选择器 &emsp;&emsp;a:link 选择所有未访问链接 &emsp;&emsp;a:visited 选择所有访问过的链接 &emsp;&emsp;a:active 选择活动链接 &emsp;&emsp;a:hover 选择鼠标在链接上面时 &emsp;&emsp;input:focus 选择具有焦点的输入元素 &emsp;&emsp;input:checked 选择每个选中的输入元素 &emsp;&emsp;input:disabled 选择每一个禁用的输入元素 &emsp;&emsp;input:enabled 选择每一个已启用的输入元素属性选择器语法 &emsp;&emsp;[attribute] 用于选取带有指定属性的元素。 &emsp;&emsp;[attribute=value] 用于选取带有指定属性和值的元素。 &emsp;&emsp;[attribute~=value] 用于选取属性值中包含指定词汇的元素。 &emsp;&emsp;[attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 &emsp;&emsp;[attribute^=value] 匹配属性值以指定值开头的每个元素。 &emsp;&emsp;[attribute$=value] 匹配属性值以指定值结尾的每个元素。 &emsp;&emsp;[attribute=value] 匹配属性值中包含指定值的每个元素。6、CSS优先级 !important 的权值最高 10000。谨慎使用！！！ 内联样式表的权值为 1000。 ID 选择器的权值为 100。 Class | 伪类 | 属性 选择器的权值为 10。 HTML 标签（类型）选择器的权值为 1。 通配符选择器的权值为 0。 权重值相同的情况下,后写的样式会覆盖前面的样式6、子盒子水平垂直居中 弹性盒.parent{ &emsp;&emsp;display: flex; &emsp;&emsp;align-items: center; &emsp;&emsp;justify-content: center;} margin .children{ &emsp;&emsp;margin: calc(父元素高度一半 - 自身高度一半) auto;} 绝对定位 .parent{ &emsp;&emsp;position: relative;} .children{ &emsp;&emsp;position: absolute; &emsp;&emsp;top: 0; &emsp;&emsp;right: 0; &emsp;&emsp;bottom: 0; &emsp;&emsp;left: 0; &emsp;&emsp;margin: auto; } 相对定位 配合margin.children{&emsp;&emsp;margin: calc(父元素高度一半) auto;&emsp;&emsp;position: relative;&emsp;&emsp;top: calc(自身高度一半);} .children{&emsp;&emsp;position: relative;&emsp;&emsp;top: calc(父元素高度一半 - 自身高度一半)&emsp;&emsp;left: calc(父元素高度一半 - 自身高度一半)} 表格 .parent{ &emsp;&emsp;display: table-cell; &emsp;&emsp;vertical-align: middle; } .children{ &emsp;&emsp; margin: 0 auto; } transform: translate 位移 .childrn{ &emsp;&emsp;transform: translate3D(calc(父元素高度一半 - 自身高度一半),calc(父元素高度一半 - 自身高度一半),0) } 三、html相关问题四、js相关问题1. js数据类型 2. 如何检测数据类型 3. null 和 undfined 区别 4. 堆和栈 5. 操作数组的方法 6. 不会修改原数组的方法 7. 深拷贝 8. JSON.parse(JSON.stringify(obj)) 有什么缺陷 9. this 10. call、apply、bind 区别 11. 严格模式 12. 闭包 13. 如解决内存泄露 14. 浏览器垃圾回收机制 15. 重绘回流 16. 性能优化 17. promise,和setTimeout区别 18. 异步队列 event loop 19. ajax,axios,fetch区别 20. 跨域 五、算法题1. 求1+N的和 用递归实现 2. 斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 求第N位结果 五、项目相关问题","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"翻墙YouTube看不停","slug":"翻墙YouTube看不停","date":"2019-04-20T05:33:57.000Z","updated":"2019-04-22T13:54:22.000Z","comments":true,"path":"2019/04/20/翻墙YouTube看不停/","link":"","permalink":"https://www.fudaqiang.com/2019/04/20/翻墙YouTube看不停/","excerpt":"","text":"翻墙1.国外服务器本人采用的Vultr服务器mac 电脑直接 command+空格 输入终端 打开终端ssh root@ 你的国外服务器的IP输入你的服务器密码yum -y install wget wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 跟着提升一步步走看到下面这写的时候就已经成功了 复制下来保持起来Congratulations, ShadowsocksR server install completed!Your Server IP : 0.0.0.0Your Server Port : 19216Your Password : teddysun.comYour Protocol : originYour obfs : plainYour Encryption Method: aes-256-cfb Welcome to visit:Enjoy it! [root@vultr shadowsocks-libev]# 已经成功啦mac电脑上下载一个shadowsockswindows电脑下载shadowsocks点击这里把你的服务器地址、服务器端口、密码、加密方式、填完 就能翻墙了","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"js日期格式化","slug":"js日期格式化","date":"2019-04-16T16:08:58.000Z","updated":"2019-04-19T12:03:08.000Z","comments":true,"path":"2019/04/17/js日期格式化/","link":"","permalink":"https://www.fudaqiang.com/2019/04/17/js日期格式化/","excerpt":"","text":"var arr =[&quot;2018-01-0212:17:00&quot;,&quot;2016/05/0112:00&quot;,&quot;2018-01-0512:29:00&quot;, &quot;2019010112&quot;,&quot;2016/09/0113:00:00&quot;,&quot;20180521185621&quot;,&quot;2019/04/09 12:00:00&quot;, &quot;2017-01-0512:45:11&quot;,&quot;2019020111&quot;,&quot;2018/05/0112:00:00&quot;,&quot;2018010113&quot;, &quot;2019-02-02 12:00:00&quot;,&quot;20181020120000&quot;]; var opt = &quot;YYYY-MM-dd HH:MM:SS&quot; function myReplace(str,reg,newStr){ return str.replace(reg,newStr) } function mySlice(str,start,end){ return str.slice(start,end) } var brr = [] for(var i = 0; i &lt; arr.length; i++){ console.log(arr[i]) var c = mySlice(arr[i],0,4) var b = myReplace(arr[i],/^\\d{4}\\D?/,&quot;&quot;) //arr[i].replace(/^\\d{4}\\D?/,&quot;&quot;) var d = mySlice(b,0,2) //b.slice(0,2) var e = myReplace(b,/^\\d{2}\\D?/,&quot;&quot;) //b.replace(/^\\d{2}\\D?/,&quot;&quot;) var f = mySlice(e,0,2) //e.slice(0,2) var g = myReplace(e,/^\\d{2}\\D?/,&quot;&quot;) //e.replace(/^\\d{2}\\D?/,&quot;&quot;) var h = mySlice(g,0,2) //g.slice(0,2) var j = myReplace(g,/^\\d{2}\\D?/,&quot;&quot;) //g.replace(/^\\d{2}\\D?/,&quot;&quot;) var k = mySlice(j,0,2) //j.slice(0,2) if(k == &quot;&quot;){ k = &quot;00&quot; } var l = myReplace(j,/^\\d{2}\\D?/,&quot;&quot;) //j.replace(/^\\d{2}\\D?/,&quot;&quot;) if(l == &quot;&quot;){ l = &quot;00&quot; } brr[i] = c + &quot;-&quot; + d + &quot;-&quot; + f +&quot; &quot;+ h + &quot;:&quot; + k + &quot;:&quot;+ l } console.log(brr)","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"js深浅拷贝","slug":"js深浅拷贝","date":"2019-04-16T03:57:16.000Z","updated":"2019-04-16T04:23:24.000Z","comments":true,"path":"2019/04/16/js深浅拷贝/","link":"","permalink":"https://www.fudaqiang.com/2019/04/16/js深浅拷贝/","excerpt":"","text":"扩展运算符 var obj = { a:1, b:2 } var copyObj = obj obj.a = 222 console.log(obj) //{a: 222, b: 2} console.log(copyObj) //{a: 222, b: 2} 浅拷贝：拷贝目标被修改，拷贝出来的变量也会改变，浅拷贝只是对其内存地址对引用。 深拷贝：拷贝目标被修改，拷贝出来的变量是不受影响的 1.扩展运算符深拷贝 var obj = { a:1, b:2 } var copyObj = {...obj} obj.a = 222 console.log(obj) //{a: 222, b: 2} console.log(copyObj) //{a: 1, b: 2} var arr = [1,2,4,6] var copyArr = [...arr] console.log(arr[0] = &quot;123&quot;) console.log(arr) //[&quot;123&quot;, 2, 4, 6] console.log(copyArr) //[1, 2, 4, 6] Object.assgin()深拷贝`js ```js","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"严格模式","slug":"严格模式","date":"2019-04-09T00:42:16.000Z","updated":"2019-04-09T00:45:34.000Z","comments":true,"path":"2019/04/09/严格模式/","link":"","permalink":"https://www.fudaqiang.com/2019/04/09/严格模式/","excerpt":"","text":"一、ECMAScript 5 严格模式1、概述除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 2、目的 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 3、使用1、将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。) &lt;script&gt; &quot;use strict&quot;; //... &lt;/script&gt; 2、针对单个函数 将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。 function strict(){ &quot;use strict&quot;; return &quot;这是严格模式。&quot;; } 二、语法和行为改变1、全局变量必须用var显示声明变量在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 &lt;script type=&quot;text/javascript&quot;&gt; &quot;use strict&quot;; v = 1; // 报错，v未声明 //name = &quot;Daotin&quot;; for (i = 0; i &lt; 2; i++) { // 报错，i未声明 } &lt;/script&gt; 不能使用 name，因为 name 是window的一个保留属性，默认为空。 2、禁止自定义的函数中的this指向window &lt;script&gt; &quot;use strict&quot;; function foo() { console.log(this); } foo(); &lt;/script&gt; 没有 “use strict” 的时候，打印 window对象，有 “use strict” 的时候，打印undefined。 3、严格模式会创建eval作用域eval会解析语句中的字符串。 &lt;script&gt; &quot;use strict&quot;; var name = &#39;Daotin&#39;; eval(&#39;var name = &quot;lvonve&quot;; console.log(name)&#39;); console.log(name); &lt;/script&gt; 如果不加 “use strict”; ，两次打印的结构都为 lvonve；加了的话，打印结果为 lvonve和Daotin。也就相当于给eval创建了一个作用域。 4、对象不能有重名的属性正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 （但是在浏览器console下面并没有显示错误信息。） &lt;script&gt; &quot;use strict&quot;; var o = { p: 1, p: 2 }; // 语法错误 &lt;/script&gt; 5、禁止删除变量严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 &quot;use strict&quot;; var x; delete x; // 语法错误 var o = Object.create(null, {&#39;x&#39;: { value: 1, configurable: true }}); delete o.x; // 删除成功","categories":[],"tags":[],"keywords":[]},{"title":"Vue指令","slug":"Vue指令","date":"2019-04-08T14:16:33.000Z","updated":"2019-05-06T07:16:32.147Z","comments":true,"path":"2019/04/08/Vue指令/","link":"","permalink":"https://www.fudaqiang.com/2019/04/08/Vue指令/","excerpt":"","text":"Vue 指令1、插值表达式插值表达式就是以双重大括号 ，类似 { {msg} } 的形式插入到 html 代码中。 1、插值表达式还可以进行简单的运算（比如加减乘除等），但是不能完全放置js代码。 2、插值表达式只能放在标签之间，而不能放在标签内部。 2、v-cloak在 使用 {{ msg }} 的方式插入数据的时候，如果网速特别慢的话， {{ msg } } 所代表的值不会立即显示出来，而会显示 这个字符串本身，怎么解决这个问题呢？ 使用 v-cloak 和 CSS 表达式结合，能够解决插值表达式闪烁的问题，这样会在网络未加载完时，不显示字符串本身。 示例： &lt;style&gt; [v-cloak] { display: none; } &lt;/style&gt; ... &lt;p v-cloak&gt; {`{ msg }`} &lt;/p&gt; 3、v-text默认 v-text 是没有闪烁问题的，但是 v-text 会覆盖元素中原本的内容，而 v-cloak 只会替换插值表达式，不会把 整个元素的内容清空。 &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; 4、v-htmlv-text 知识插入的纯文本格式内容，而 v-html 可以插入为 html 标签的代码，并解析出来。 &lt;span v-html=&quot;msg&quot;&gt;&lt;/span&gt; ... data: { msg: &#39;&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;&#39; }, 5、v-bindv-bind 是 Vue中，提供的用于绑定属性的指令。将一个属性的值变成动态值。 注意： v-bind: 指令可以被简写为: &lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle + &#39;123&#39;&quot;&gt; ... data: { mytitle: &#39;这是一个自己定义的title&#39; }, title 里面的内容就不是字符串了，而是会将 data 中的变量进行替换得到一个字符串整体。 6、v-onv-on ：给某个元素绑定事件监听函数。注意，函数必须封装在methods内。 注意：v-on: 指令可以被简写为@ &lt;input type=&quot;button&quot; value=&quot;按钮&quot; :title=&quot;mytitle + &#39;123&#39;&quot; v-on:click=&quot;show&quot;&gt; ... data: { mytitle: &#39;这是一个自己定义的title&#39; }, methods: { // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () { alert(&#39;Hello&#39;) } } 7、v-modelv-bind 只能实现数据的单向绑定，从 M 自动绑定到 V（即修改 data 的数据，自动同步到 html）， 无法实现数据的双向绑定。 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定（不仅可以修改 data 的数据，自动同步到 html，也可以修改 html 的代码，同步到 data 数据）。 注意： v-model 只能运用在 表单元素中。 8、v-for8.1、v-for 循环普通数组 我们之前如果要循环赋值给 p 标签 data中 list=[1,2,3,4,5,6]; 数组的话，会这样写： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{list[0]}}&lt;/p&gt; &lt;p&gt;{{list[1]}}&lt;/p&gt; &lt;p&gt;{{list[2]}}&lt;/p&gt; &lt;p&gt;{{list[3]}}&lt;/p&gt; &lt;p&gt;{{list[4]}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [1, 2, 3, 4, 5, 6] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 这样的话，就会很繁琐。而 v-for 会提供循环遍历 list 数组来给 p 标签赋值。如下： &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(item, i) in list&quot;&gt;索引：{{i}} --- 项：{{item}}&lt;/p&gt; &lt;!-- 索引：0 --- 项：1 索引：1 --- 项：2 索引：2 --- 项：3 索引：3 --- 项：4 索引：4 --- 项：5 索引：5 --- 项：6 --&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [1, 2, 3, 4, 5, 6] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.2、v-for 循环对象数组 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(user, i) in list&quot;&gt;Id：{{ user.id }} --- 名字：{{ user.name }} --- 索引：{{i}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { list: [ { id: 1, name: &#39;zs1&#39; }, { id: 2, name: &#39;zs2&#39; }, { id: 3, name: &#39;zs3&#39; }, { id: 4, name: &#39;zs4&#39; } ] }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.3、v-for 循环对象 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for=&quot;(val, key, i) in user&quot;&gt;值是： {{ val }} --- 键是： {{key}} -- 索引： {{i}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { user: { id: 1, name: &#39;Tony Stark&#39;, gender: &#39;男&#39; } }, methods: {} }); &lt;/script&gt; &lt;/body&gt; 8.4、v-for 循环数字 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- in 后面我们放过普通数组，对象数组，对象，还可以放数字 --&gt; &lt;p v-for=&quot;count in 10&quot;&gt;这是第 {{ count }} 次循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: {}, methods: {} }); &lt;/script&gt; &lt;/body&gt; 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始。 8.5、v-for 循环 key 属性 key 属性可以使得每一遍历的项是唯一的。 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt; &lt;/div&gt; &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number或者string --&gt; &lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt; &lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt; &lt;p v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt;{{item.id}} --- {{item.name}} &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { id: &#39;&#39;, name: &#39;&#39;, list: [ { id: 1, name: &#39;李斯&#39; }, { id: 2, name: &#39;嬴政&#39; }, { id: 3, name: &#39;赵高&#39; }, { id: 4, name: &#39;韩非&#39; }, { id: 5, name: &#39;荀子&#39; } ] }, methods: { add() { // 添加方法 this.list.unshift({ id: this.id, name: this.name }) } } }); &lt;/script&gt; &lt;/body&gt; 9、v-if/v-showv-if 和 v-show 都可以控制元素的显示与否。但是实现原理不同。 v-if：决定某些元素是否存在 (加载性能更高,某个元素不需要被频繁切换时,则应该使用v-if) v-show：决定某些元素是否显示 (操作性能更高,如果某个元素需要被频繁切换,则应该使用v-show) v-if：每次都会重新删除或创建元素。 v-show ： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式。 所以，如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show； 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if。 &lt;h3 v-if=&quot;true&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=&quot;true&quot;&gt;这是用v-show控制的元素&lt;/h3&gt; 有了v-if就有v-else-if和v-else v-if和v-show指令中除了可以放简单的值外，还可以放表达式 &lt;h3 v-if=&quot;age &lt; 18&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;!--age是data中的一个属性--&gt; &lt;h3 v-else-if=&quot;age &lt; 28&quot;&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-else&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;!--v-else不用写条件--&gt; 注意：v-if和v-else-if和v-else之间，不要加任何其他元素，否则会报错。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]},{"title":"CommonJS、AMD、CMD、ES6","slug":"CommonJS、AMD、CMD、ES6","date":"2019-04-08T11:47:28.000Z","updated":"2019-04-09T00:44:06.000Z","comments":true,"path":"2019/04/08/CommonJS、AMD、CMD、ES6/","link":"","permalink":"https://www.fudaqiang.com/2019/04/08/CommonJS、AMD、CMD、ES6/","excerpt":"","text":"前端模块化：CommonJs、AMD、CMD、ES6 模块化的好处： 模块化的开发可以提升代码的可复用性，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD、以及ES6的模块系统。 一、CommonJsnode.js是commonJS规范的主要实践者，它有四个重要的环境变量位为模块化的实现提供支持： module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口(不推荐直接用exports)，用require加载模块。 //定义模块math.js var num = 0; function add(a, b){ return a + b; } module.exports = { //在这里写需要向外暴露的函数、变量 add:add, num } //引用自定义的模块时，参数包含路径，可省略.js var math = require(&#39;./math&#39;) math.add(2,5) //7 //引用node-module包时，不需要带路径 var http = require(&#39;http&#39;) http.createService(()=&gt;{ }).listen(3000) CommonJS用同步的方法加载模块。在服务端，模块文化都存在本地磁盘，读取速度非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 二、AMD和require.jsAMD规范采用异步方式加载模块，模块的加载不影响它后面的语句运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。首先我们需要引入require.js文件和一个入口文件main.js中配置require.config()并规定项目中用到等基础模块 /*网页中引入ruire.js及main.js*/ &lt;script src=&quot;require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; /* main.js 入口文件/主模块*/ require.config({ baseUrl: &quot;js/lib&quot;, //基路径 path:{ &quot;jquery&quot;:&quot;jquery.min&quot;, //实际路径js/lib/jquery.min.js &quot;underscore&quot;:&quot;underscore.min&quot; } }); // 执行基本操作 require([&quot;jquery&quot;,&quot;underscore&quot;],function($,un){ //some code here }) 引用模块的时候，我们将模块名放在[]中作为require()的第一个参数；如果我们定义的模块本身也依赖其他模块，那就需要将他们放在[]中作为define()的第一个参数。 //定义math.js define(function(){ var basicNum = 0; var add = function(x, y){ return x + y; }; return { add: add, basicNum: basicNum }; }); //定义一个依赖underscore.js 模块 defind([&#39;underscore&#39;],function(nu){ var classify = function(list){ nu.conntBy(list,function(num){ return num &gt; 30 ? &#39;old&#39; : &#39;young&#39;; }) }; return{ classify: classify }; }) //引用模块，将模块放在[]内 require([&#39;jquery&#39;,&#39;math&#39;],function($,m){ var sum = math.add(1,2); $(&quot;#box&quot;).html(sum) }); 三、CMD和sea.jsrequire.js在申明依赖的模块时会在第一之间加载并执行模块内的代码： define([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],function(a,b,c){ //在最前面声明并初始化了要用到的所有模块 if(false){ //即便没用到某个模块，b 但在声明 b 时已经提前执行了 b.foo() } }) CMD是另一种js模块化方案，它于AMD很类似，不同点在于：AMD推崇依赖前置、提前执行，CMD推崇就近、延迟执行。此规范其实是在sea.js推广过程中产出的 //AMD写法 define([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],function(a,b,c){ //在最前面声明并初始化了要用到的所有模块 if(false){ //即便没用到某个模块，b 但在声明 b 时已经提前执行了 b.foo() } }) //CMD写法 // 定义模块 math.js define(function(require,export,module){ var $ = require(&#39;jquery&#39;); var add = function(a,b){ return a + b; } exports.add = add; }) //加载模块 seajs.use([&#39;math.js&#39;],function(math){ var sum = math.add(1,2) }) AMD与CMD - 真正的不同 还是执行时间// AMD recommended define([&#39;a&#39;, &#39;b&#39;], function(a, b){ a.doSomething(); // 依赖前置，提前执行 b.doSomething(); }) // CMD recommanded define(function(require, exports, module){ var a = require(&quot;a&quot;); a.doSomething(); var b = require(&quot;b&quot;); b.doSomething(); // 依赖就近，延迟执行 }) 四、ES6 ModuleES6在语言标准的层面上，实现了模块功能，而且实现的相当简单，只为成为浏览器和服务器通用的模块定义方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 /** 定义模块 math.js **/ var basicNum = 0 var add = function(a,b){ return a + b; }; export {basicNum, add}; // 抛出变量 export var PI = 3.14; export var bar = foo; //抛出 函数 export function foo(){ console.log(&#39;I am not bar.&#39;); } //默认抛出 一个js文件只能有一个默认抛出 export default (a, b)=&gt;{ return a + b } /** 引用模块 **/ import{basicNum, add } from &#39;./math&#39;; function test(el){ el.innerHTML = add(1,basicNum); } import { foo as bar } from &quot;./math&quot;; //as 设置别名 bar(); import * as math from &quot;./math&quot;; //*所有抛出 都配置到 math身上 math.PI math.foo() 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default 命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。 五、 ES6 模块与 CommonJS 模块的差异1. CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2. CommonJS模块是运行时加载，ES6模块是在编译时输出接口 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码， import 时采用静态命令的形式。即在 import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。","categories":[{"name":"技术 模块化","slug":"技术-模块化","permalink":"https://www.fudaqiang.com/categories/技术-模块化/"}],"tags":[],"keywords":[{"name":"技术 模块化","slug":"技术-模块化","permalink":"https://www.fudaqiang.com/categories/技术-模块化/"}]},{"title":"js数组去重","slug":"javascript数组去重","date":"2018-10-08T12:03:06.000Z","updated":"2019-05-06T07:22:16.939Z","comments":true,"path":"2018/10/08/javascript数组去重/","link":"","permalink":"https://www.fudaqiang.com/2018/10/08/javascript数组去重/","excerpt":"","text":"set去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] var newSet = new Set(arr) console.log([...newSet]) Array.prototype.includes() var newArr = [] for (var i of arr) { if (!newArr.includes(i)) { newArr.push(i) } } console.log(newArr) 相邻元素去重var arr = [5,3,1,2,3,4,5,1,2,3,2,1,4,5] var ar = arr.sort((a, b) =&gt; { return a - b; }) for (var i = 0; i &lt; ar.length; i++) { for (var j = 0; j &lt; ar.length; j++) { if (ar[i] == ar[j + 1]) { ar.splice(i, 1) } } } console.log(ar) Array.prototype.reduce() var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] init = [] var result = arr.sort().reduce((init, current) =&gt; { console.log(init, current) if (init.length === 0 || init[init.length - 1] !== current) { init.push(current); } return init; }, []); console.log(result) 对象去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] var obj = {} for (var i of arr) { console.log(i) obj[i] = i } var brr = Object.values(obj) console.log(brr) filter 去重var arr = [5,3,1,2,&quot;c&quot;,&quot;a&quot;,3,4,5,&quot;c&quot;,1,&quot;b&quot;,2,&quot;a&quot;,3,2,1,4,5] function unique(arr) { return arr.filter((item, index, brr) =&gt; { return brr.indexOf(item) === index }) } console.log(unique(arr))","categories":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://www.fudaqiang.com/categories/技术/"}]}]}